15663번 N과M(9)
---
1. for문에 중복된 수가 들어가면 안되기에 일반적인 순열코드에서 list를 추가에 해당 for문에 들어간 숫자들을 저장한다.
2. 저장한 숫자들과 check배열을 통해 해당 값이 사용되었는지와 해당 수가 for문에서 사용하였는지를 체크해서 문제해결



15664번 N과M(10)
---
1. 입력값들을 오름차순으로 정렬한다.
2. 일반적인 조합코드의 for문의 인덱스를 배열의 다음값과 비교해 현재값과 다른값이 나올때까지 인덱스를 변경하여 


3085번 사탕게임
---
1. 어떻게 전체 다 체크할것인지 고민 -> 각 좌표에서 오른쪽과 밑으로 한번씩 스왑하고 모든 배열에서 사탕의 최대 갯수를 구한다.


2493번 탑
---
1. 인덱스와 해당하는 값을 스택으로 보관한다.
2. 인덱스를 줄여나가면서 스택에 있는 값과 비교하여 스택 값이 크다면 push를 해나간다.
3. 스택에 있는 값이 작다면 현재값보다 스택값이 나올때 까지 pop하거나 Empty일떄까지 pop한다.

2503번 숫자야구
---
1. 먼저 모든 값을 스트링으로 저장해서 입력값과 비교하려했다. -> 너무 많은 스트링 메모리 낭비 및 배열 메모리 낭비
2. 단순 순열을 통해 모든경우를 생성하고, 이 값을 check함수에 넣어 입력값과 비교 (StringBuffer를 사용하여, 조금이나마 메모리 절약)
3. 모든 입력값과 비교하여 하나라도 해당하지 않는다면 return을 통해 바로 빠져나오도록 


17952번 과제는 끝나지 않아!
---
1. 입력이 들어오면 시간을 줄여주고 0이면 결과값을 1 증가시켜주고, 아니면 스택에 넣는다.
2. 0이고 스택이 비어있지않으면 스택에서 값을 빼오고 시간을 줄이고 조건비교하고 맞지않으면 다시 스택에 넣는다.



10971번 외판원 순회2
---
1. 완전탐색을 통해 모든 길을 다 거쳤다.


7568번 덩치
---
1. 완전탐색으로 자신이 다른 사람보다 덩치가 크거나 비교할수 없다면 순위를 높혔다.(값을 낮추었다.)


1914번 하노이 탑
---
1. int ,long형으로 재귀를 통해 하노이 탑 구현한다 . 메모리 초과
2. 20 초과할시 BigInteger를 통해 해결한다. BigInteger은 문자로 저장하기 떄문에 거의 무한대로 저장가능하다.


3190번 뱀
---
1. deque을 이용하여 시간마다 뱀의 머리의 좌표를 앞으로 넣고 뒤쪽부분은 사과를 만나지 않으면 빼준다.
2. 인덱스를 넘어가거나 자신의 꼬리에 부딪히면 끝나도록 구현



17298번 오큰수
--- 
1. 위의 2493번 탑과 비슷한 문제라고 판단.  시간초과 및 틀림
2. 시간초과 -> StringBuilder를 통해 해결
3. 탑에서는 같은 크기가 존재하지 않았지만, 오큰수에서는 같은 크기가 존재하여 이를 처리하여 
