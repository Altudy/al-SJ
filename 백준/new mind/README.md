2667
---
1. DFS를 통해 구현 (해당 그룹을  숫자로 표현해 다시 DFS를 호출하지 않게 한다.)

1987(알파벳)
---
1. dfs와 vector를 통해 구현. vector를 통해 지금까지 사용한 알파벳을 저장 -> 시간초과
2. 비트연산을 이용하여 지금까지 사용한 알파벳을 저장

1068 (트리)
---
1. 트리를 이용하여 구현
2. 아직 트리에 대한 숙련도가 부족한거 같다.

1260 (DFS와 BFS)
---
1. DFS를 재귀적으로 구현
2. BFS를 queue를 이용해 구현

2178 (미로 찾기)
---
1. BFS 연습

9095(1,2,3더하기)
---
1. 2차원 DP로 해결
2. 1차원 DP로도 가능 

2631(줄세우기)＊
---
1. 가장 긴 증가배열을 만들고 전체 길이에서 뺀다.
2. cache[i] = i번 전까지 최대로 긴 증가배열의 길이

1562 (계단 수)＊
---
1. 2차원 배열로 한  DP를 생각하다 실패 
2. 3차원 DP로 설계 
3. 비트 연산을 사용하여 0~9까지의 숫자를 사용햇는지 또한 DP로 설계

2482 (생상환)
---
1. 시작점을 기준으로 캐시 초기화 -> 시간 초과
2. 캐시를 한번만 초기화 -> 틀림
3. 1번의 색을 추가했을때와 나머지의 경우를 따로 캐시를 둔다. -> 성공
4. 예외적인 상황을 잘 처리해야한다.


2133 (타일 채우기)
---
1. 예외적인 상황을 고려하지 못해 틀림 (처음 점화식 dp[i] = 3*dp[i-2]+2*dp[i-4]) // 섣부른 일반화
2. 예외적인 상황을 고려하여 수식을 다시 작성 (점화식 dp[i] = 3*dp[i-2]+2dp[i-4]+2*dp[i-6] +...+2*dp[0]) // dp[0] = 1 로 
3. 예외적인 상황을 생각하지 못하였는지 고려해야한다

1520 (내리막 길)
---
1. 오타로 인한 오류
2. 전형적인 
